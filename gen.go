package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

func main() {
	workDir, err := os.Getwd()
	if err != nil {
		log.Fatalln(err)
	}
	curFile := os.Getenv("GOFILE")
	if workDir == "" || curFile == "" {
		return
	}

	f, err := os.OpenFile(workDir+"/"+curFile, os.O_RDONLY, 0666)
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, curFile, f, parser.ParseComments)
	if err != nil {
		log.Fatalln(err)
	}

	structs := make([]*structMetadata, 0)
	ast.Inspect(astFile, func(node ast.Node) bool {
		if g, ok := node.(*ast.GenDecl); ok && g.Tok == token.TYPE {
			if r := getStructMetadata(g); r != nil {
				structs = append(structs, r)
			}
			return false
		}
		return true
	})
	/*
		_ = ast.Print(nil, astFile)
	*/
	for _, v := range structs {
		log.Println(v)
	}

	buf := bytes.NewBuffer(make([]byte, 0, 1024*1024))

	pkgName := astFile.Name.Name
	err = ossTemplate.Execute(buf, struct {
		Timestamp time.Time
		Source    string
		Package   string
		Structs   []*structMetadata
	}{
		Timestamp: time.Now(),
		Source:    curFile,
		Package:   pkgName,
		Structs:   structs,
	})
	if err != nil {
		log.Fatalln(err)
	}
	log.Println(string(buf.Bytes()))

	formated, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalln(err)
	}
	outf, err := os.OpenFile(fmt.Sprintf("%s/%s_gen.go", workDir, curFile[:len(curFile)-3]), os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatalln(err)
	}
	defer outf.Close()

	_, err = outf.Write(formated)
	if err != nil {
		log.Fatalln(err)
	}
}

type structMetadata struct {
	Name   string
	Fields map[string]string
	ID     string
}

func getStructMetadata(a *ast.GenDecl) *structMetadata {
	if a.Tok != token.TYPE || len(a.Specs) != 1 {
		return nil
	}
	ts, ok := a.Specs[0].(*ast.TypeSpec)
	if !ok {
		return nil
	}
	st, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil
	}
	f := make(map[string]string)

	for _, v := range st.Fields.List {
		if len(v.Names) != 1 || v.Type == nil {
			continue
		}
		name := v.Names[0].Name
		if name == "Base" {
			continue
		}
		typ, ok := v.Type.(*ast.Ident)
		if !ok {
			continue
		}
		f[name] = typ.Name
	}

	id := "0"
	if a.Doc != nil {
		for _, v := range a.Doc.List {
			if strings.Contains(v.Text, "eventID") {
				str := v.Text
				str = str[strings.Index(str, "eventID")+7:]
				id = strings.TrimSpace(str)
				break
			}
		}
	}

	return &structMetadata{
		Name:   ts.Name.Name,
		Fields: f,
		ID:     id,
	}
}

var ossTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"Conv": func(s string) string {
		if strings.Contains(s, "int") {
			return "%d"
		} else if strings.Contains(s, "string") {
			return "%s"
		} else {
			return "%v"
		}
	},
}).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{.Timestamp}}
// SourceFile {{.Source}}

package {{.Package}}

import "fmt"
{{range $x := .Structs}}
func (s *{{$x.Name}}) Marshal() string {
    return fmt.Sprintf("%s {{range $k, $v := $x.Fields}}` + "`" + `{{Conv $v}}{{end}}", s.Base.Marshal(){{range $k, $v := $x.Fields}}, s.{{$k}}{{end}})
}

func (s *{{$x.Name}}) GetBase() *GATACharBase {
    s.Base.DataType = {{$x.ID}}
    return &s.Base
}

func (s *{{$x.Name}}) GetEventName() string {
    return "{{$x.ID}}"
}
{{end}}
`))
